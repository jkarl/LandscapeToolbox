#################################################################################
### CALIBRATION CHECKING SCRIPT
### The goal here is to take a DIMA that contains calibration data, grab those data, and serve up information on how the observers compare on the major calibration indicators
### A lot of things are defined as values before they're called so that this can be altered as needed and to add hooks for a Shiny implementation
## Reporting out on the following indicators
## LPI : Foliar Cover, Bare Soil, Litter, Basal Cover, Rock Fragments, Vegetation Heights (by woody/herbaceous and height classes)
## Gap Intercept : Gap counts and proprtion of plot in gaps (by size classes)
#################################################################################

#################################################################################
### BASIC CONFIGURATION
## Getting the packages
require(RODBC)
require(dplyr)

# Filepath to find the DIMA
path.read <- "C:/Users/username/Documents/Projects/"
# DIMA filename
name.dima <- "training__calibration_DIMA_4.1.mdb"
# Filepath to write out the .csv of calibration results
path.write <- "C:/Users/username/Documents/Projects/"
# Filename for the .csv that you want to write out the results in
filename.output <- "calibration_results.csv"
#################################################################################

#################################################################################
### SETTING CALIBRATION TOLERANCES
## In the end, we need everyone to be within tolerances, which is ±5% from the mean for anything reported in percentages and ±2 on the species counts
## I'm still defining them as values in a list in case we want to let people set different tolerances eventually

## Initialize the tolerances list
tolerances <- list()

## LPI tolerances
# These four are the tolerance for (maximum observed percent on plot - minimum observed percent on plot)
tolerances$lpi$foliar.percent.range <- 10
tolerances$lpi$baresoil.percent.range <- 10
tolerances$lpi$basalcover.percent.range <- 10
tolerances$lpi$rockfragments.percent.range <- 10
# These four are maximum tolerance in abs(individual's observed percentage - mean plot percentage)
tolerances$lpi$foliar.percent <- tolerances$lpi$foliar.percent.range/2
tolerances$lpi$baresoil.percent <- tolerances$lpi$baresoil.percent.range/2
tolerances$lpi$basalcover.percent <- tolerances$lpi$basalcover.percent.range/2
tolerances$lpi$rockfragments.percent <- tolerances$lpi$rockfragments.percent.range/2
# Tolerance for (maximum observed count within a height class - minimum observed count within a height class)
tolerances$lpi$heights.count.range <- 4
# Tolerance for abs(individual's observed count within a height class - mean observed count on plot within a height class)
tolerances$lpi$heights.count <- tolerances$lpi$heights.count.range/2


## Gap tolerances
tolerances$gaps$gap.pct.range <- 10
tolerances$gaps$gap.percent <- tolerances$gaps$gap.pct.range/2
# gap.count is currently unused
tolerances$gaps$gap.count <- 2
#################################################################################


#################################################################################
### PULLING THE DATA FROM A DATABASE
## Specify the DIMA filepath
dima.location <- paste(path.read, name.dima, sep = "/")

## Initialize our queries list
queries <- list()

## SQL query for getting a table of all LPI hits by layer with recorder, observer,, heights and species for heights by woody and herbaceous, point location on line,
## point number on line, line, plot, site, and date
queries$lpi <- "SELECT joinSitePlotLine.SiteID, joinSitePlotLine.PlotID, joinSitePlotLine.PlotKey, joinSitePlotLine.LineID, tblLPIHeader.FormDate, tblLPIHeader.Observer, tblLPIHeader.Recorder, tblLPIDetail.PointLoc, tblLPIDetail.PointNbr, tblLPIDetail.TopCanopy, tblLPIDetail.Lower1, tblLPIDetail.Lower2, tblLPIDetail.Lower3, tblLPIDetail.Lower4, tblLPIDetail.SoilSurface, tblLPIDetail.HeightWoody, tblLPIDetail.SpeciesWoody, tblLPIDetail.HeightHerbaceous, tblLPIDetail.SpeciesHerbaceous
FROM joinSitePlotLine INNER JOIN (tblLPIHeader LEFT JOIN tblLPIDetail ON tblLPIHeader.RecKey = tblLPIDetail.RecKey) ON joinSitePlotLine.LineKey = tblLPIHeader.LineKey;"

## SQL query for getting a table of gaps with observer, recorder, line, plot,site, and date
queries$gaps <- "SELECT joinSitePlotLine.SiteID, joinSitePlotLine.PlotID, joinSitePlotLine.PlotKey, joinSitePlotLine.LineID, tblGapHeader.FormDate, tblGapHeader.Observer, tblGapHeader.Recorder, tblGapDetail.Gap, tblGapHeader.LineLengthAmount
FROM joinSitePlotLine INNER JOIN (tblGapHeader INNER JOIN tblGapDetail ON tblGapHeader.RecKey = tblGapDetail.RecKey) ON joinSitePlotLine.LineKey = tblGapHeader.LineKey;"


## Let's get some tables extracted from the specified DIMA!
## Initialize the lists to keep all our data frames in
lpi <- list()
gaps <- list()

## Note that I'm using the function odbcConnectAccess2007() because I have 64-bit R and 64-bit Access installed. If your Access install is 32-bit, use odbcConnectAccess() in 32-bit R
## I also never trust factored fields to work with functions that I want to use, so I avoid them in the first place
## This is just connecting to the database and running the SQL queries then storing the results
lpi$raw <- odbcConnectAccess2007(dima.location) %>% sqlQuery(., queries$lpi, stringsAsFactors = F)
gaps$raw <- odbcConnectAccess2007(dima.location) %>% sqlQuery(., queries$gaps, stringsAsFactors = F)
odbcCloseAll()

## The line length is in meters, but we need cm, so we'll quickly do that
gaps$raw$LineLengthAmount <- gaps$raw$LineLengthAmount*100

## We also want the plot keys to be strings, not numeric values
lpi$raw$PlotKey <- as.character(lpi$raw$PlotKey)
gaps$raw$PlotKey <- as.character(gaps$raw$PlotKey)

## We'll set up some objects we can use to populate options in the Shiny tool that maybe will one day be built
sites.plots <- rbind(gaps$raw[,c("SiteID", "PlotID", "PlotKey")], lpi$raw[,c("SiteID", "PlotID", "PlotKey")]) %>% unique()
observers.all <- c(gaps$raw$Observer, lpi$raw$Observer) %>% unique()

## If you want to see your options for the calibration PlotKey, Plot-, and SiteID, use this
# sites.plots %>% View()

## Where's the calibration data? Specify the SiteID and the PlotID, although all we really need is the key
## This was originally—naively—written to use a combination of the Site- and PlotIDs on a one-at-a-time basis
## We've moved onto a loop that'll look at all the plots in a database using the plotkeys that were found
calibration.SiteID <- "Canyonlands Calibration"
calibration.PlotID <- "Calibration: NWDO"
## Humans struggle with reliably typing out a plot key, so let's just extract it based on the friendlier Site- and PlotIDs
calibration.PlotKey <- sites.plots$PlotKey[sites.plots$SiteID == calibration.SiteID & sites.plots$PlotID == calibration.PlotID]
#################################################################################


#################################################################################
############# KICKING OFF THE LOOP THAT'LL ITERATE THROUGH ALL PLOTS ############
#################################################################################
## For general purposes, we need to make a final data table that has calibration information for every plot
## in the database instead of just one at a time. So, we'll loop through each of the plot keys in turn and
## mash together the results from the data associated to each key.
## Obviously, the conclusion to this needs to come at the end of all the calibration work, so if you comment this
## out make sure you also comment out that section

## This is predicated on the assumption that the database contains only calibration plots. If there's just one calibration
## plot, just make sure it's set up above. If you have multiple calibration plots, let this do its thing and then
## just filter/subset at the end of it all. Your life will be much better for it.

for (n in seq_along(sites.plots$PlotKey)){
  calibration.PlotKey <- sites.plots$PlotKey[n]
  
## I'm aware that this is slow and inelegant, but the script was written assuming a single plot and this is much easier
## than working to rewrite to do calculations without looping and it's not that much data, really
#################################################################################
  
  
  
#################################################################################
### CALIBRATION CHECKING FOR LPI
## The indicators being evaluated are Foliar Cover, Bare Soil, Litter, Basal Cover, Rock Fragments, Vegetation Heights (by woody/herbaceous and height classes)
## This is currently set up so that it'll work regardless of how many lines were read

## Create a data frame of just the LPI data from the calibration plot so we can get to work looking at it
## This first line is from the dark times when we didn't use plot keys
# lpi$calibration.raw <- lpi$raw %>% subset(SiteID == calibration.SiteID) %>% subset(PlotID == calibration.PlotID)
lpi$calibration.raw <- lpi$raw %>% subset(PlotKey == calibration.PlotKey)
## Add in some extra variables so we can calculate the indicators relatively painlessly. Normally I wouldn't do this, but summarize() is fighting me and this should make it possible
## First up is to add a 1 to all observations where the top canopy hit isn't a "None" so that we can find the sum to know how many foliar hits there were
lpi$calibration.raw$foliar.cover[lpi$calibration.raw$TopCanopy != "None"] <- 1
## Likewise, do the same sort of thing to all the points where there's a species code at the soil surface, which here is just anywhere where a standard non-vegetative code was not found
surface.codes <- c("S", "LC", "M", "D", "W", "CY", "EL", "R", "GR", "CB", "ST", "BY", "BR")
lpi$calibration.raw$basal.cover[!(lpi$calibration.raw$SoilSurface %in% surface.codes)] <- 1
## And a variable for if the last hit was a rock of some sort that wasn't bedrock because that's not a "rock fragment"
lpi$calibration.raw$rock.fragments[lpi$calibration.raw$SoilSurface %in% surface.codes[8:12]] <- 1
## One for bare ground. Assume it's true and then invalidate it wherever the surface code isn't S or CY, the top code isn't None, or there's anything in Lower1:Lower4. Clunky, but effective
lpi$calibration.raw$bare.soil <- 1
lpi$calibration.raw$bare.soil[!(lpi$calibration.raw$SoilSurface %in% c("S", "CY"))] <- 0
lpi$calibration.raw$bare.soil[lpi$calibration.raw$TopCanopy != "None"] <- 0
lpi$calibration.raw$bare.soil[lpi$calibration.raw$Lower1 != ""] <- 0
lpi$calibration.raw$bare.soil[lpi$calibration.raw$Lower2 != ""] <- 0
lpi$calibration.raw$bare.soil[lpi$calibration.raw$Lower3 != ""] <- 0
lpi$calibration.raw$bare.soil[lpi$calibration.raw$Lower4 != ""] <- 0

## Adding in the height classes for woody and herbaceous. Eventually I'll generalize these so that custom classes can be used, but it's not worth it right now.
lpi$calibration.raw$woody.0.50[lpi$calibration.raw$HeightWoody <= 50] <- 1
lpi$calibration.raw$woody.51.200[lpi$calibration.raw$HeightWoody > 50 & lpi$calibration.raw$HeightWoody <= 200] <- 1
lpi$calibration.raw$woody.201.500[lpi$calibration.raw$HeightWoody > 200 & lpi$calibration.raw$HeightWoody <= 500] <- 1
lpi$calibration.raw$woody.501[lpi$calibration.raw$HeightWoody > 500] <- 1
lpi$calibration.raw$herbaceous.0.50[lpi$calibration.raw$HeightHerbaceous <= 50] <- 1
lpi$calibration.raw$herbaceous.51.200[lpi$calibration.raw$HeightHerbaceous > 50 & lpi$calibration.raw$HeightHerbaceous <= 200] <- 1
lpi$calibration.raw$herbaceous.201.500[lpi$calibration.raw$HeightHerbaceous > 200 & lpi$calibration.raw$HeightHerbaceous <= 500] <- 1
lpi$calibration.raw$herbaceous.501[lpi$calibration.raw$HeightHerbaceous > 500] <- 1



## Taking those raw data and converting them into the various indicators we want for each observer, specifically: percent total foliar cover, percent bare soil, percent basal cover, percent rock fragments,
## and the woody and herbaceous heights by height classes
lpi$calibration <- lpi$calibration.raw %>% group_by(Observer, SiteID, PlotID, PlotKey) %>%
  summarize(records.lpi = n(),
            foliar.hits = sum(foliar.cover, na.rm = T),
            basal.hits = sum(basal.cover, na.rm = T),
            rock.frag.hits = sum(rock.fragments, na.rm = T),
            bare.soil.hits = sum(bare.soil, na.rm = T),
            ## All these heights are still hard-coded, but will probably eventually be generalized. It's just a real pain to do so
            woody.plants.0.50.count = sum(woody.0.50, na.rm = T),
            woody.plants.51.200.count = sum(woody.51.200, na.rm = T),
            woody.plants.201.500.count = sum(woody.201.500, na.rm = T),
            woody.plants.501.count = sum(woody.501, na.rm = T),
            herbaceous.plants.0.50.count = sum(herbaceous.0.50, na.rm = T),
            herbaceous.plants.51.200.count = sum(herbaceous.51.200, na.rm = T),
            herbaceous.plants.201.500.count = sum(herbaceous.201.500, na.rm = T),
            herbaceous.plants.501.count = sum(herbaceous.501, na.rm = T))

## Calculating percentages for the appropriate indicators
lpi$calibration <- lpi$calibration %>% mutate(foliar.cover.pct = 100*(foliar.hits/records.lpi),
                                              basal.cover.pct = 100*(basal.hits/records.lpi),
                                              rock.fragments.pct = 100*(rock.frag.hits/records.lpi),
                                              bare.soil.pct = 100*(bare.soil.hits/records.lpi))

## Now to add in the min and max for each indicator, again all hard-coded
lpi$calibration <- lpi$calibration %>% mutate(foliar.cover.pct.min = min(foliar.cover.pct),
                                              basal.cover.pct.min = min(basal.cover.pct),
                                              rock.fragments.pct.min = min(rock.fragments.pct),
                                              bare.soil.pct.min = min(bare.soil.pct),
                                              woody.plants.0.50.count.min = min(woody.plants.0.50.count),
                                              woody.plants.51.200.count.min = min(woody.plants.51.200.count),
                                              woody.plants.201.500.count.min = min(woody.plants.201.500.count),
                                              woody.plants.501.count.min = min(woody.plants.501.count),
                                              herbaceous.plants.0.50.count.min = min(herbaceous.plants.0.50.count),
                                              herbaceous.plants.51.200.count.min = min(herbaceous.plants.51.200.count),
                                              herbaceous.plants.201.500.count.min = min(herbaceous.plants.201.500.count),
                                              herbaceous.plants.501.count.min = min(herbaceous.plants.501.count),
                                              foliar.cover.pct.max = max(foliar.cover.pct),
                                              basal.cover.pct.max = max(basal.cover.pct),
                                              rock.fragments.pct.max = max(rock.fragments.pct),
                                              bare.soil.pct.max = max(bare.soil.pct),
                                              woody.plants.0.50.count.max = max(woody.plants.0.50.count),
                                              woody.plants.51.200.count.max = max(woody.plants.51.200.count),
                                              woody.plants.201.500.count.max = max(woody.plants.201.500.count),
                                              woody.plants.501.count.max = max(woody.plants.501.count),
                                              herbaceous.plants.0.50.count.max = max(herbaceous.plants.0.50.count),
                                              herbaceous.plants.51.200.count.max = max(herbaceous.plants.51.200.count),
                                              herbaceous.plants.201.500.count.max = max(herbaceous.plants.201.500.count),
                                              herbaceous.plants.501.count.max = max(herbaceous.plants.501.count))

## Now to add in the means for each indicator, again all hard-coded
lpi$calibration <- lpi$calibration %>% mutate(foliar.cover.pct.mean = mean(foliar.cover.pct),
                                              basal.cover.pct.mean = mean(basal.cover.pct),
                                              rock.fragments.pct.mean = mean(rock.fragments.pct),
                                              bare.soil.pct.mean = mean(bare.soil.pct),
                                              woody.plants.0.50.mean = mean(woody.plants.0.50.count),
                                              woody.plants.51.200.mean = mean(woody.plants.51.200.count),
                                              woody.plants.201.500.mean = mean(woody.plants.201.500.count),
                                              woody.plants.501.mean = mean(woody.plants.501.count),
                                              herbaceous.plants.0.50.mean = mean(herbaceous.plants.0.50.count),
                                              herbaceous.plants.51.200.mean = mean(herbaceous.plants.51.200.count),
                                              herbaceous.plants.201.500.mean = mean(herbaceous.plants.201.500.count),
                                              herbaceous.plants.501.mean = mean(herbaceous.plants.501.count))

## And now to add the calibrated-or-not logical values! Still all hard-coded to check that the minimum-to-maximum range is less than or equal to the tolerance
lpi$calibration$foliar.cover.calibrated <- (lpi$calibration$foliar.cover.pct.max - lpi$calibration$foliar.cover.pct.min) <= tolerances$lpi$foliar.percent.range
lpi$calibration$basal.cover.calibrated <- (lpi$calibration$basal.cover.pct.max - lpi$calibration$basal.cover.pct.min) <= tolerances$lpi$basalcover.percent.range
lpi$calibration$bare.soil.calibrated <- (lpi$calibration$bare.soil.pct.max - lpi$calibration$bare.soil.pct.min) <= tolerances$lpi$baresoil.percent.range
lpi$calibration$rock.fragments.calibrated <- (lpi$calibration$rock.fragments.pct.max - lpi$calibration$rock.fragments.pct.min) <= tolerances$lpi$rockfragments.percent.range

lpi$calibration$woody.plants.0.50.calibrated <- (lpi$calibration$woody.plants.0.50.count.max - lpi$calibration$woody.plants.0.50.count.min) <= tolerances$lpi$heights.count.range
lpi$calibration$woody.plants.51.200.calibrated <- (lpi$calibration$woody.plants.51.200.count.max - lpi$calibration$woody.plants.51.200.count.min) <= tolerances$lpi$heights.count.range
lpi$calibration$woody.plants.201.500.calibrated <- (lpi$calibration$woody.plants.201.500.count.max - lpi$calibration$woody.plants.201.500.count.min) <= tolerances$lpi$heights.count.range
lpi$calibration$woody.plants.501.calibrated <- (lpi$calibration$woody.plants.501.count.max - lpi$calibration$woody.plants.501.count.min) < tolerances$lpi$heights.count.range
lpi$calibration$herbaceous.plants.0.50.calibrated <- (lpi$calibration$herbaceous.plants.0.50.count.max - lpi$calibration$herbaceous.plants.0.50.count.min) <= tolerances$lpi$heights.count.range
lpi$calibration$herbaceous.plants.51.200.calibrated <- (lpi$calibration$herbaceous.plants.51.200.count.max - lpi$calibration$herbaceous.plants.51.200.count.min) <= tolerances$lpi$heights.count.range
lpi$calibration$herbaceous.plants.201.500.calibrated <- (lpi$calibration$herbaceous.plants.201.500.count.max - lpi$calibration$herbaceous.plants.201.500.count.min) <= tolerances$lpi$heights.count.range
lpi$calibration$herbaceous.plants.501.calibrated <- (lpi$calibration$herbaceous.plants.501.count.max - lpi$calibration$herbaceous.plants.501.count.min) <= tolerances$lpi$heights.count.range

## The calibration checks using the deviation from the mean as the metric. This is not the standard practice
# lpi$calibration$foliar.cover.calibrated <- abs(lpi$calibration$foliar.cover.pct - lpi$calibration$foliar.cover.pct.mean) <= tolerances$lpi$foliar.percent
# lpi$calibration$basal.cover.calibrated <- abs(lpi$calibration$basal.cover.pct - lpi$calibration$basal.cover.pct.mean) <= tolerances$lpi$basalcover.percent
# lpi$calibration$bare.soil.calibrated <- abs(lpi$calibration$bare.soil.pct - lpi$calibration$bare.soil.pct.mean) <= tolerances$lpi$baresoil.percent
# lpi$calibration$rock.fragments.calibrated <- abs(lpi$calibration$rock.fragments.pct - lpi$calibration$rock.fragments.pct.mean) <= tolerances$lpi$rockfragments.percent
# 
# lpi$calibration$woody.plants.0.50.calibrated <- abs(lpi$calibration$woody.plants.0.50.count - lpi$calibration$woody.plants.0.50.mean) <= tolerances$lpi$heights.count
# lpi$calibration$woody.plants.51.200.calibrated <- abs(lpi$calibration$woody.plants.51.200.count - lpi$calibration$woody.plants.51.200.mean) <= tolerances$lpi$heights.count
# lpi$calibration$woody.plants.201.500.calibrated <- abs(lpi$calibration$woody.plants.201.500.count - lpi$calibration$woody.plants.201.500.mean) <= tolerances$lpi$heights.count
# lpi$calibration$woody.plants.501.calibrated <- abs(lpi$calibration$woody.plants.501.count - lpi$calibration$woody.plants.501.mean) < tolerances$lpi$heights.count
# lpi$calibration$herbaceous.plants.0.50.calibrated <- abs(lpi$calibration$herbaceous.plants.0.50.count - lpi$calibration$herbaceous.plants.0.50.mean) <= tolerances$lpi$heights.count
# lpi$calibration$herbaceous.plants.51.200.calibrated <- abs(lpi$calibration$herbaceous.plants.51.200.count - lpi$calibration$herbaceous.plants.51.200.mean) <= tolerances$lpi$heights.count
# lpi$calibration$herbaceous.plants.201.500.calibrated <- abs(lpi$calibration$herbaceous.plants.201.500.count - lpi$calibration$herbaceous.plants.201.500.mean) <= tolerances$lpi$heights.count
# lpi$calibration$herbaceous.plants.501.calibrated <- abs(lpi$calibration$herbaceous.plants.501.count - lpi$calibration$herbaceous.plants.501.mean) <= tolerances$lpi$heights.count
#################################################################################

#################################################################################
### CALIBRATION CHECKING FOR GAPS
## The indicator being evaluated percentage of line[s] in gaps of lengths 25-50 cm, 51-100 cm, 101-200 cm, and >200 cm. Additionally, the gap count for each size class is included
## This is currently set up so that it'll work regardless of how many lines were read

## Subset to just the data from the calibration plot
## This used to use a combination of Site- and PlotID, but much more reasonably, if less readably, now uses plot keys
# gaps$calibration.raw <- gaps$raw %>% subset(SiteID == calibration.SiteID) %>% subset(PlotID == calibration.PlotID)
gaps$calibration.raw <- gaps$raw %>% subset(PlotKey == calibration.PlotKey)

## Writing in variables to keep track of what size class these belong to
gaps$calibration.raw$gap.25.50[gaps$calibration.raw$Gap >= 25 & gaps$calibration.raw$Gap <= 50] <- 1
gaps$calibration.raw$gap.51.100[gaps$calibration.raw$Gap > 50 & gaps$calibration.raw$Gap <= 100] <- 1
gaps$calibration.raw$gap.101.200[gaps$calibration.raw$Gap > 100 & gaps$calibration.raw$Gap <= 200] <- 1
gaps$calibration.raw$gap.201[gaps$calibration.raw$Gap > 200] <- 1

## Counting gaps and finding their sums. This was the quick-and-dirty solution where I just filtered by the classes and kept merging them into the same calibration data frame
gaps$calibration <- gaps$calibration.raw %>% group_by(Observer, SiteID, PlotID, PlotKey) %>% filter(gap.25.50 == 1) %>% summarize(gap.25.50.count = n(),
                                                                                                         gap.25.50.cm.sum = sum(Gap, na.rm = T))
gaps$calibration <- gaps$calibration.raw %>% group_by(Observer, SiteID, PlotID, PlotKey) %>% filter(gap.51.100 == 1) %>% summarize(gap.51.100.count = n(),
                                                                                                          gap.51.100.cm.sum = sum(Gap, na.rm = T)) %>% merge (x = ., y = gaps$calibration, all = T)
gaps$calibration <- gaps$calibration.raw %>% group_by(Observer, SiteID, PlotID, PlotKey) %>% filter(gap.101.200 == 1) %>% summarize(gap.101.200.count = n(),
                                                                                                           gap.101.200.cm.sum = sum(Gap, na.rm = T)) %>% merge (x = ., y = gaps$calibration, all = T)
gaps$calibration <- gaps$calibration.raw %>% group_by(Observer, SiteID, PlotID, PlotKey) %>% filter(gap.201 == 1) %>% summarize(gap.201.count = n(),
                                                                                                       gap.201.cm.sum = sum(Gap, na.rm = T)) %>% merge (x = ., y = gaps$calibration, all = T)

## Adding in the line lengths on a per-observer basis in case they maybe read different lengths even though they shouldn't
gaps$calibration <- gaps$calibration.raw %>% group_by(Observer, SiteID, PlotID, PlotKey) %>% summarize(length.total.cm = first(LineLengthAmount)) %>% merge (x = ., y = gaps$calibration, all = T)

## We've got NAs, but those are really 0s because this data frame is restricted to observers who completed gap forms, so let's change them
gaps$calibration <- gaps$calibration %>% replace(., is.na(.), 0)

## We need the minimum and maximum gap counts and percent in each gap class
gaps$calibration$gap.25.50.pct.max <- 100*max(gaps$calibration$gap.25.50.cm.sum/gaps$calibration$length.total.cm)
gaps$calibration$gap.51.100.pct.max <- 100*max(gaps$calibration$gap.51.100.cm.sum/gaps$calibration$length.total.cm)
gaps$calibration$gap.101.200.pct.max <- 100*max(gaps$calibration$gap.101.200.cm.sum/gaps$calibration$length.total.cm)
gaps$calibration$gap.201.pct.max <- 100*max(gaps$calibration$gap.201.cm.sum/gaps$calibration$length.total.cm)
gaps$calibration$gap.25.50.pct.min <- 100*min(gaps$calibration$gap.25.50.cm.sum/gaps$calibration$length.total.cm)
gaps$calibration$gap.51.100.pct.min <- 100*min(gaps$calibration$gap.51.100.cm.sum/gaps$calibration$length.total.cm)
gaps$calibration$gap.101.200.pct.min <- 100*min(gaps$calibration$gap.101.200.cm.sum/gaps$calibration$length.total.cm)
gaps$calibration$gap.201.pct.min <- 100*min(gaps$calibration$gap.201.cm.sum/gaps$calibration$length.total.cm)

gaps$calibration$gap.25.50.count.max = max(gaps$calibration$gap.25.50.count)
gaps$calibration$gap.51.100.count.max = max(gaps$calibration$gap.51.100.count)
gaps$calibration$gap.101.200.count.max = max(gaps$calibration$gap.101.200.count)
gaps$calibration$gap.201.count.max = max(gaps$calibration$gap.201.count)
gaps$calibration$gap.25.50.count.min = min(gaps$calibration$gap.25.50.count)
gaps$calibration$gap.51.100.count.min = min(gaps$calibration$gap.51.100.count)
gaps$calibration$gap.101.200.count.min = min(gaps$calibration$gap.101.200.count)
gaps$calibration$gap.201.count.min = min(gaps$calibration$gap.201.count)

## Now we'll add the percent of length and the mean percent of length in each gap class and mean count
gaps$calibration <- gaps$calibration %>% mutate(gap.25.50.pct = 100*(gap.25.50.cm.sum/length.total.cm),
                                                gap.51.100.pct = 100*(gap.51.100.cm.sum/length.total.cm),
                                                gap.101.200.pct = 100*(gap.101.200.cm.sum/length.total.cm),
                                                gap.201.pct = 100*(gap.201.cm.sum/length.total.cm),
                                                gap.25.50.pct.mean = 100*(mean(gap.25.50.cm.sum, na.rm = T)/length.total.cm),
                                                gap.51.100.pct.mean = 100*(mean(gap.51.100.cm.sum, na.rm = T)/length.total.cm),
                                                gap.101.200.pct.mean = 100*(mean(gap.101.200.cm.sum, na.rm = T)/length.total.cm),
                                                gap.201.pct.mean = 100*(mean(gap.201.cm.sum, na.rm = T)/length.total.cm),
                                                gap.25.50.count.mean = mean(gap.25.50.count, na.rm = T),
                                                gap.51.100.count.mean = mean(gap.51.100.count, na.rm = T),
                                                gap.101.200.count.mean = mean(gap.101.200.count, na.rm = T),
                                                gap.201.count.mean = mean(gap.201.count, na.rm = T))

## Final step is to decide if they're calibrated or not.
gaps$calibration$gap.25.50.pct.calibrated <- (gaps$calibration$gap.25.50.pct.max - gaps$calibration$gap.25.50.pct.min) <= tolerances$gaps$gap.pct.range
gaps$calibration$gap.51.100.pct.calibrated <- (gaps$calibration$gap.51.100.pct.max - gaps$calibration$gap.51.100.pct.min) <= tolerances$gaps$gap.pct.range
gaps$calibration$gap.101.200.pct.calibrated <- (gaps$calibration$gap.101.200.pct.max - gaps$calibration$gap.101.200.pct.min) <= tolerances$gaps$gap.pct.range
gaps$calibration$gap.201.pct.calibrated <- (gaps$calibration$gap.201.pct.max - gaps$calibration$gap.201.pct.min) <= tolerances$gaps$gap.pct.range

gaps$calibration$gap.25.50.count.calibrated <- (gaps$calibration$gap.25.50.count.max - gaps$calibration$gap.25.50.count.min) <= tolerances$gaps$gap.count
gaps$calibration$gap.51.100.count.calibrated <- (gaps$calibration$gap.51.100.count.max - gaps$calibration$gap.51.100.count.min) <= tolerances$gaps$gap.count
gaps$calibration$gap.101.200.count.calibrated <- (gaps$calibration$gap.101.200.count.max - gaps$calibration$gap.101.200.count.min) <= tolerances$gaps$gap.count
gaps$calibration$gap.201.count.calibrated <- (gaps$calibration$gap.201.count.max - gaps$calibration$gap.201.count.min) <= tolerances$gaps$gap.count

## Figuring out calibration when the rule is "within 5% of the mean" but that's not standard practice for determining calibration
# gaps$calibration$gap.25.50.pct.calibrated <- abs(gaps$calibration$gap.25.50.pct - gaps$calibration$gap.25.50.pct.mean) <= tolerances$gaps$gap.percent
# gaps$calibration$gap.51.100.pct.calibrated <- abs(gaps$calibration$gap.51.100.pct - gaps$calibration$gap.51.100.pct.mean) <= tolerances$gaps$gap.percent
# gaps$calibration$gap.101.200.pct.calibrated <- abs(gaps$calibration$gap.101.200.pct - gaps$calibration$gap.101.200.pct.mean) <= tolerances$gaps$gap.percent
# gaps$calibration$gap.201.pct.calibrated <- abs(gaps$calibration$gap.201.pct - gaps$calibration$gap.201.pct.mean) <= tolerances$gaps$gap.percent
# 
# gaps$calibration$gap.25.50.count.calibrated <- abs(gaps$calibration$gap.25.50.count - gaps$calibration$gap.25.50.count.mean) <= tolerances$gaps$gap.count
# gaps$calibration$gap.51.100.count.calibrated <- abs(gaps$calibration$gap.51.100.count - gaps$calibration$gap.51.100.count.mean) <= tolerances$gaps$gap.count
# gaps$calibration$gap.101.200.count.calibrated <- abs(gaps$calibration$gap.101.200.count - gaps$calibration$gap.101.200.count.mean) <= tolerances$gaps$gap.count
# gaps$calibration$gap.201.count.calibrated <- abs(gaps$calibration$gap.201.count - gaps$calibration$gap.201.count.mean) <= tolerances$gaps$gap.count
#################################################################################

#################################################################################
############# CONCLUDING THE LOOP THAT'LL ITERATE THROUGH ALL PLOTS #############
#################################################################################
## And now we wrap up the loop set in motion above. This will result in a single data frame output that contains all the calibration
## information for each observer by plot.

## On the first trip through the loop, it just creates calibration.results
  if (n < 2){
    calibration.results <- merge(lpi$calibration, gaps$calibration, all = T)
    ## On subsequent loops, the calibration.results data frame exists, so the new plot's results are just appended to avoid overwriting
  } else {
    calibration.results <- merge(lpi$calibration, gaps$calibration, all = T) %>% rbind(., calibration.results)
  }
}

#################################################################################


#################################################################################
### COMBINING AND WRITING CALIBRATION RESULTS
## So, now there're two data frames—one for LPI and one for gaps—but we want them combined and written out
## This needs to be uncommented to combine things if you aren't using the whole-database loop!
## calibration.results <- merge(lpi$calibration, gaps$calibration, all = T)
write.csv(calibration.results, paste(path.write, filename.output, sep = "/"))

#################################################################################
